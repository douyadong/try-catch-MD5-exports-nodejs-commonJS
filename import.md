# node.js基于模块化开发，及trycatch基本点、MD5介绍、exports使用规范;
## try catch
```
try{
    正常代码，但一般是同步方法,node中会使用async await解决
}catch(e){
    如果try里面的同步代码出现错误，那么会执行catch里的代码;
}finall{
    代码无论执行的是try还是catch最终都会再次执行此处的代码;
}
```
## node
### node是基于commonJS模块化开发的(exports);不需要向前端开发一样，还要引用requirejs(define);
### 有三种模块
 1. 基于node的核心模块，比如http;
 2. 第三方模块，利用npm 下载,第三方模块一般都有导出项，引用的时候，直接var a=require('下载时的模块名');
 3. 用户模块(自己写的模块)，使用路径标识符引用，如果无导出项，直接引用即可，require('./**.js');
 如果定义的模块只是单纯的定义了成员，而没有导出，其他模块无法访问此模块中的成员;如果有导出，用exports向外暴露成员，通过对象来接收，而且不会造成全局污染;在一个模块中，可以写多个exports(module.exports)，最终引入的时候，设置一个变量，会接收到所有导出项;
 4. 当使用require来引用一个其他模块的时候，那么，会编译执行被引入模块中的js代码;

## 判断页面是前端加载，还是node加载;
1. 在页面中复制一段数据，鼠标右键打开源代码，在源代码中搜索复制的数据，如果可以搜到就是node端渲染,反之客户端渲染;

## 前端使用ajax请求node端;
1. 前端通过ajax请求的后台接口，后台不能使用重定向等服务器刷新技术
2. 当前端ajax向node发送请求时，因为前后端都在整个项目都是自己实现的，所以不存在跨域问题;请求的地址就是在node端设置的路由，然后在node端再发起请求，拿到数据，通过res.send(data)或者res.json(data)返回到前端ajax的success或err函数中;

## 前后端都是用模板引擎
1. 在后端使用art-template时，如果再前端也是用art-template，现在前端页面引用art-template，在重新设置语法规则(如果不设置，node端会直接渲染，使得前端ajax的数据渲染无效),重新设置语法的时候注意转义符的使用;

## 中间件注意点:
1. 在一个中间件中，next()和res.send()等相关的一系列方法，不要同时调用；
2.如果中间件中，还没有处理完毕，则只能用next()进入到下一个中间件中去处理，如果处理完毕之后，就表示当前中间件可以调用res.send()等相关方法，直接结束当前响应，所以再通过next调用下一个中间件，就没有意义了;
## 使用第三方中间件，利用app.use()
## 静态资源配置可以使用app.use('',express.statci(''));
## 使用express.Router(),创建路由之后，还要使用app.use()注册路由;
## 导入解析post提交的数据，第三方插件body-parser;要在注册路由之前引入;

# MD5
1. MD5加密后输出的是32位长度的字符串;
2. 相同的内容使用MD5加密后，得到的内容是一致的;
3. MD5加密后的字符串是无法[反向解密]的，此处的反向解密，说的是无法通过算法的形式，直接进行反向解密，但那时可以通过暴力碰撞的形式进行暴力破解;
4. 为了防止暴力破解，可以通过加盐处理，如12334(^&*^&^&^&))括号里的即为加的盐;防止密码过于简单被破解，提高密码的复杂度;